import { inject, useAttrs, computed, watch, unref, ref, onMounted, nextTick, shallowReactive, onUnmounted, defineComponent, createElementBlock, openBlock, createVNode, shallowRef, provide, Fragment, createElementVNode, mergeProps, renderSlot, onUpdated, onBeforeUnmount, normalizeClass, createBlock, createCommentVNode, Transition, normalizeProps, withCtx, guardReactiveProps, createTextVNode, toDisplayString, renderList, useSlots } from "vue";
import mapboxgl from "mapbox-gl";
import MapboxGeocoder from "@mapbox/mapbox-gl-geocoder";
function useMap() {
  const map = inject("mapbox-map", null);
  return {
    map
  };
}
const cache = /* @__PURE__ */ new Map();
const regex = /onMb([A-Z])(.+)/;
function getOriginalEvent(vueEventName) {
  if (!cache.has(vueEventName)) {
    cache.set(
      vueEventName,
      vueEventName.replace(regex, (match, $1, $2) => $1.toLowerCase() + $2)
    );
  }
  return cache.get(vueEventName);
}
function useEventsBinding(emitFn, mapboxElement, events2 = [], layerId = null) {
  const attrs = useAttrs();
  const vueEventNames = computed(
    () => Object.entries(attrs).filter(([name, value]) => name.startsWith("on") && typeof value === "function").map(([name]) => name)
  );
  const unbindFunctions = /* @__PURE__ */ new Map();
  function unbindEvents(eventNames) {
    if (!Array.isArray(eventNames)) {
      return;
    }
    eventNames.forEach((eventName) => {
      const unbindFn = unbindFunctions.get(eventName);
      if (typeof unbindFn === "function") {
        unbindFn();
      }
    });
  }
  function bindEvents(eventNames) {
    if (!Array.isArray(eventNames)) {
      return;
    }
    eventNames.forEach((eventName) => {
      const originalEvent = getOriginalEvent(eventName);
      if (!events2.includes(originalEvent)) {
        return;
      }
      const handler = (...payload) => {
        emitFn(`mb-${originalEvent}`, ...payload);
      };
      if (layerId) {
        unref(mapboxElement).on(originalEvent, layerId, handler);
        unbindFunctions.set(eventName, () => {
          unref(mapboxElement).off(originalEvent, layerId, handler);
        });
      } else {
        unref(mapboxElement).on(originalEvent, handler);
        unbindFunctions.set(eventName, () => {
          unref(mapboxElement).off(originalEvent, handler);
        });
      }
    });
  }
  watch(
    vueEventNames,
    (newVueEventNames, oldVueEventNames) => {
      const eventNamesToDelete = Array.isArray(newVueEventNames) ? (oldVueEventNames ?? []).filter(
        (oldVueEventName) => !newVueEventNames.includes(oldVueEventName)
      ) : oldVueEventNames ?? [];
      const eventNamesToAdd = Array.isArray(oldVueEventNames) ? (newVueEventNames ?? []).filter(
        (newVueEventName) => !oldVueEventNames.includes(newVueEventName)
      ) : newVueEventNames ?? [];
      if (unref(mapboxElement)) {
        unbindEvents(eventNamesToDelete);
        bindEvents(eventNamesToAdd);
      } else {
        const unwatch = watch(mapboxElement, (newValue) => {
          if (newValue) {
            unbindEvents(eventNamesToDelete);
            bindEvents(eventNamesToAdd);
            unwatch();
          }
        });
      }
    },
    { immediate: true }
  );
}
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function usePropsBinding(props, mapboxElement, propsConfig2) {
  function bindProps(element) {
    Object.keys(props).filter((prop) => props[prop] !== void 0 && props[prop] !== null).forEach((prop) => {
      var _a;
      const setMethodName = prop === "mapStyle" ? "setStyle" : `set${capitalizeFirstLetter(prop)}`;
      const methodExists = typeof element[setMethodName] === "function";
      const propNeedsBinding = typeof propsConfig2[prop] === "undefined" || "bind" in propsConfig2[prop] ? ((_a = propsConfig2[prop]) == null ? void 0 : _a.bind) ?? false : true;
      if (!methodExists || !propNeedsBinding) {
        return;
      }
      const { type } = propsConfig2[prop];
      const options = {
        deep: type === Object || Array.isArray(type) && type.includes(Object)
      };
      watch(
        () => props[prop],
        (newValue) => {
          element[setMethodName](newValue);
        },
        options
      );
    });
  }
  if (unref(mapboxElement)) {
    bindProps(unref(mapboxElement));
  } else {
    const unwatch = watch(mapboxElement, (newValue) => {
      if (newValue) {
        bindProps(newValue);
        unwatch();
      }
    });
  }
}
function useControl(ControlConstructor, { propsConfig: propsConfig2, props, emit, events: events2 = [] }) {
  const { map } = useMap();
  const control = ref();
  if (Array.isArray(events2) && events2.length) {
    useEventsBinding(emit, control, events2);
  }
  if (typeof propsConfig2 !== "undefined") {
    usePropsBinding(props, control, propsConfig2);
  }
  watch(
    () => props.position,
    (newValue) => {
      if (unref(map)) {
        unref(map).removeControl(unref(control)).addControl(unref(control), newValue);
      }
    }
  );
  onMounted(async () => {
    const ctrl = new ControlConstructor(props);
    if (unref(map)) {
      unref(map).addControl(ctrl, props.position);
    }
    await nextTick();
    if (ControlConstructor === mapboxgl.GeolocateControl && !ctrl._setup) {
      const tmpControl = shallowReactive(ctrl);
      const unwatch = watch(tmpControl, (reactiveCtrl) => {
        if (reactiveCtrl._setup) {
          control.value = ctrl;
          unwatch();
        }
      });
    } else {
      control.value = ctrl;
    }
  });
  onUnmounted(() => {
    if (unref(control) && unref(map) && unref(map).hasControl(unref(control))) {
      unref(map).removeControl(unref(control));
    }
  });
  return {
    control,
    map
  };
}
const _hoisted_1$6 = ["id"];
const propsConfig$9 = {
  /**
   * Id of the layer
   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addlayer
   * @type {string}
   */
  id: {
    type: String,
    required: true
  },
  /**
   * Options for the layer
   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addlayer
   * @see  https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers
   * @type {object}
   */
  options: {
    type: Object,
    default: () => ({})
  },
  /**
   * The ID of an existing layer to insert the new layer before.
   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addlayer
   * @type {string}
   */
  beforeId: {
    type: String,
    default: void 0
  }
};
const events$5 = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "mousemove",
  "mouseenter",
  "mouseleave",
  "mouseover",
  "mouseout",
  "contextmenu",
  "touchstart",
  "touchend",
  "touchcancel"
];
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "MapboxLayer",
  props: propsConfig$9,
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { map } = useMap();
    const options = computed(() => {
      const opts = { ...props.options, id: props.id };
      if (opts.paint === null || opts.paint === void 0) {
        delete opts.paint;
      }
      if (opts.layout === null || opts.layout === void 0) {
        delete opts.layout;
      }
      return opts;
    });
    useEventsBinding(emit, map, events$5, props.id);
    function removeLayer() {
      if (typeof unref(map).getLayer(props.id) !== "undefined") {
        unref(map).removeLayer(props.id);
      }
    }
    function removeSource() {
      if (typeof unref(map).getSource(props.id) !== "undefined") {
        unref(map).removeSource(props.id);
      }
    }
    onMounted(() => {
      removeLayer();
      removeSource();
      unref(map).addLayer(unref(options), props.beforeId);
    });
    onUnmounted(() => {
      removeLayer();
      removeSource();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", { id: _ctx.id }, null, 8, _hoisted_1$6);
    };
  }
});
const _hoisted_1$5 = ["id"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "MapboxSource",
  props: {
    options: {},
    id: {}
  },
  setup(__props) {
    const props = __props;
    const { map } = useMap();
    watch(
      () => props.options.data,
      (newValue) => {
        unref(map).getSource(props.id).setData(newValue);
      }
    );
    onMounted(() => {
      unref(map).addSource(props.id, props.options);
    });
    onUnmounted(() => {
      const { _layers: layers } = unref(map).style;
      Object.values(layers).forEach((value) => {
        if (value.source === props.id) {
          unref(map).removeLayer(value.id);
        }
      });
      unref(map).removeSource(props.id);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", { id: _ctx.id }, null, 8, _hoisted_1$5);
    };
  }
});
const _hoisted_1$4 = ["id"];
const propsConfig$8 = {
  /**
   * The source of the data for the clustered points,
   * must be a String or an Object of GeoJSON format.
   * @type {string | GeoJSON}
   */
  data: {
    type: [String, Object],
    required: true
  },
  /**
   * The max zoom to cluster points on
   * @type {number}
   */
  clusterMaxZoom: {
    type: Number,
    default: 14
  },
  /**
   * Radius of each cluster when clustering point
   * @type {number}
   */
  clusterRadius: {
    type: Number,
    default: 50
  },
  /**
   * Minimum number of points necessary to form a cluster.
   * @type {number}
   */
  clusterMinPoints: {
    type: Number,
    default: 2
  },
  /**
   * An object defining custom properties on the generated clusters.
   * @see  https://docs.mapbox.com/style-spec/reference/sources/#geojson-clusterProperties
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster-html/
   * @type {object}
   */
  clusterProperties: {
    type: Object,
    default: () => ({})
  },
  /**
   * The layout configuration for the clusters circles
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster/
   * @type {object}
   */
  clustersLayout: {
    type: Object,
    default: () => ({})
  },
  /**
   * The paint configuration for the clusters circles
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster/
   * @type {object}
   */
  clustersPaint: {
    type: Object,
    default: () => ({
      "circle-color": "#000",
      "circle-radius": 40
    })
  },
  /**
   * The layout configuration for the clusters count
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster/
   * @type {object}
   */
  clusterCountLayout: {
    type: Object,
    default: () => ({
      "text-field": ["get", "point_count_abbreviated"]
    })
  },
  /**
   * The paint configuration for the clusters count
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster/
   * @type {object}
   */
  clusterCountPaint: {
    type: Object,
    default: () => ({
      "text-color": "white"
    })
  },
  /**
   * The type of the unclustered points layer
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster/
   * @type {string}
   */
  unclusteredPointLayerType: {
    type: String,
    default: "circle"
  },
  /**
   * The layout configuration for the unclustered points
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster/
   * @type {object}
   */
  unclusteredPointLayout: {
    type: Object,
    default: () => ({})
  },
  /**
   * The paint configuration for the unclustered points
   * @see  https://docs.mapbox.com/mapbox-gl-js/example/cluster/
   * @type {object}
   */
  unclusteredPointPaint: {
    type: Object,
    default: () => ({
      "circle-color": "#000",
      "circle-radius": 4
    })
  }
};
let index = 0;
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "MapboxCluster",
  props: propsConfig$8,
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { map } = useMap();
    const id = ref(`mb-cluster-${index}`);
    index += 1;
    const getId = (suffix) => `${unref(id)}-${suffix}`;
    const sourceId = computed(() => getId("source"));
    const source = computed(() => {
      const { data, clusterMaxZoom, clusterRadius, clusterMinPoints, clusterProperties } = props;
      return {
        type: "geojson",
        cluster: true,
        data,
        clusterMaxZoom,
        clusterRadius,
        clusterMinPoints,
        clusterProperties
      };
    });
    const clustersLayer = computed(() => ({
      id: getId("clusters"),
      type: "circle",
      source: unref(sourceId),
      filter: ["has", "point_count"],
      layout: props.clustersLayout,
      paint: props.clustersPaint
    }));
    const clusterCountLayer = computed(() => ({
      id: getId("cluster-count"),
      type: "symbol",
      source: unref(sourceId),
      filter: ["has", "point_count"],
      layout: props.clusterCountLayout,
      paint: props.clusterCountPaint
    }));
    const unclusteredPointLayer = computed(() => ({
      id: getId("unclustered-point"),
      type: props.unclusteredPointLayerType,
      source: unref(sourceId),
      filter: ["!", ["has", "point_count"]],
      layout: props.unclusteredPointLayout,
      paint: props.unclusteredPointPaint
    }));
    function clustersClickHandler(event) {
      const feature = unref(map).queryRenderedFeatures(event.point, {
        layers: [unref(clustersLayer).id]
      })[0];
      const { cluster_id: clusterId } = feature.properties;
      emit("mb-cluster-click", clusterId, event);
      if (event.defaultPrevented) {
        return;
      }
      unref(map).getSource(unref(sourceId)).getClusterExpansionZoom(clusterId, (err, zoom) => {
        if (err) {
          return;
        }
        unref(map).easeTo({
          center: feature.geometry.coordinates,
          zoom
        });
      });
    }
    function clustersMouseenterHandler() {
      unref(map).getCanvas().style.cursor = "pointer";
    }
    function clustersMouseleaveHandler() {
      unref(map).getCanvas().style.cursor = "";
    }
    function unclusteredPointClickHandler(event) {
      const [feature] = event.features;
      emit("mb-feature-click", feature, event);
    }
    function unclusteredPointMouseenterHandler(event) {
      const [feature] = event.features;
      emit("mb-feature-mouseenter", feature, event);
      unref(map).getCanvas().style.cursor = "pointer";
    }
    function unclusteredPointMouseleaveHandler(event) {
      emit("mb-feature-mouseleave", event);
      unref(map).getCanvas().style.cursor = "";
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", { id: id.value }, [
        createVNode(_sfc_main$c, {
          id: sourceId.value,
          options: source.value
        }, null, 8, ["id", "options"]),
        createVNode(_sfc_main$d, {
          id: clustersLayer.value.id,
          options: clustersLayer.value,
          onMbClick: clustersClickHandler,
          onMbMouseenter: clustersMouseenterHandler,
          onMbMouseleave: clustersMouseleaveHandler
        }, null, 8, ["id", "options"]),
        createVNode(_sfc_main$d, {
          id: clusterCountLayer.value.id,
          options: clusterCountLayer.value
        }, null, 8, ["id", "options"]),
        createVNode(_sfc_main$d, {
          id: unclusteredPointLayer.value.id,
          options: unclusteredPointLayer.value,
          onMbClick: unclusteredPointClickHandler,
          onMbMouseenter: unclusteredPointMouseenterHandler,
          onMbMouseleave: unclusteredPointMouseleaveHandler
        }, null, 8, ["id", "options"])
      ], 8, _hoisted_1$4);
    };
  }
});
if (!mapboxgl) {
  throw new Error("mapboxgl is not installed.");
}
if (!MapboxGeocoder) {
  throw new Error("MapboxGeocoder is not installed.");
}
const propsConfig$7 = {
  accessToken: {
    type: String,
    default: "no-token"
  },
  zoom: {
    type: Number,
    default: 16
  },
  flyTo: {
    type: [Boolean, Object],
    default: true
  },
  placeholder: {
    type: String,
    default: "Search"
  },
  proximity: {
    type: [Object, Array, String],
    default: "ip"
  },
  trackProximity: {
    type: Boolean,
    default: true
  },
  collapsed: {
    type: Boolean,
    default: false
  },
  clearAndBlurOnEsc: {
    type: Boolean,
    default: false
  },
  clearOnBlur: {
    type: Boolean,
    default: false
  },
  bbox: {
    type: Array,
    default: () => []
  },
  countries: {
    type: String,
    default: ""
  },
  types: {
    type: String,
    default: "place"
  },
  minLength: {
    type: Number,
    default: 2
  },
  limit: {
    type: Number,
    default: 5
  },
  language: {
    type: String,
    default: void 0
  },
  filter: {
    type: Function,
    default: void 0
  },
  localGeocoder: {
    type: Function,
    default: void 0
  },
  reverseMode: {
    type: String,
    default: "distance"
  },
  reverseGeocode: {
    type: Boolean,
    default: false
  },
  enableEventLogging: {
    type: Boolean,
    default: false
  },
  marker: {
    type: Boolean,
    default: true
  },
  render: {
    type: Function,
    default: void 0
  },
  getItemValue: {
    type: Function,
    default: (item) => item.place_name
  },
  mode: {
    type: String,
    default: "mapbox.places"
  },
  localGeocoderOnly: {
    type: Boolean,
    default: false
  }
};
const events$4 = ["clear", "loading", "results", "result", "error"];
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "MapboxGeocoder",
  props: propsConfig$7,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const root = ref();
    const options = computed(() => {
      const opts = {
        mapboxgl,
        ...props,
        accessToken: mapboxgl.accessToken ?? props.accessToken
      };
      if (!opts.reverseGeocode || true) {
        delete opts.reverseMode;
      }
      return opts;
    });
    const { control, map } = useControl(MapboxGeocoder, {
      propsConfig: propsConfig$7,
      props: unref(options),
      emit,
      events: events$4
    });
    onMounted(() => {
      const stop = watch(control, (newValue) => {
        if (newValue && !unref(map) && unref(root)) {
          newValue.addTo(unref(root));
          stop();
        }
      });
    });
    __expose({ control });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "root",
        ref: root
      }, null, 512);
    };
  }
});
const _hoisted_1$3 = { key: 0 };
const _hoisted_2 = { key: 1 };
if (!mapboxgl) {
  throw new Error("mapboxgl is not installed.");
}
const { LngLatBounds, LngLat: LngLat$1 } = mapboxgl;
const propsConfig$6 = {
  accessToken: {
    type: String,
    default: "no-token"
  },
  container: {
    type: [typeof HTMLElement !== "undefined" && HTMLElement, String],
    default: void 0
  },
  minZoom: {
    type: Number,
    default: 0
  },
  maxZoom: {
    type: Number,
    default: 22
  },
  minPitch: {
    type: Number,
    default: 0
  },
  maxPitch: {
    type: Number,
    default: 60
  },
  mapStyle: {
    type: [Object, String],
    required: true
  },
  hash: {
    type: Boolean,
    default: false
  },
  interactive: {
    type: Boolean,
    default: true
  },
  bearingSnap: {
    type: Number,
    default: 7
  },
  pitchWithRotate: {
    type: Boolean,
    default: true
  },
  clickTolerance: {
    type: Number,
    default: 3
  },
  attributionControl: {
    type: Boolean,
    default: true
  },
  customAttribution: {
    type: [String, Array],
    default: null
  },
  logoPosition: {
    type: String,
    default: "bottom-left"
  },
  failIfMajorPerformanceCaveat: {
    type: Boolean,
    default: false
  },
  preserveDrawingBuffer: {
    type: Boolean,
    default: false
  },
  antialias: {
    type: Boolean,
    default: false
  },
  refreshExpiredTiles: {
    type: Boolean,
    default: true
  },
  maxBounds: {
    type: [LngLatBounds, Array],
    default: void 0
  },
  scrollZoom: {
    type: [Boolean, Object],
    default: true
  },
  boxZoom: {
    type: Boolean,
    default: true
  },
  dragRotate: {
    type: Boolean,
    default: true
  },
  dragPan: {
    type: [Boolean, Object],
    default: true
  },
  keyboard: {
    type: Boolean,
    default: true
  },
  doubleClickZoom: {
    type: Boolean,
    default: true
  },
  touchZoomRotate: {
    type: [Boolean, Object],
    default: true
  },
  trackResize: {
    type: Boolean,
    default: true
  },
  center: {
    type: [LngLat$1, Array, Object],
    default: () => [0, 0]
  },
  zoom: {
    type: Number,
    default: 0
  },
  bearing: {
    type: Number,
    default: 0
  },
  pitch: {
    type: Number,
    default: 0
  },
  bounds: {
    type: [LngLatBounds, Array],
    default: void 0
  },
  fitBoundsOptions: {
    type: Object,
    default: null
  },
  renderWorldCopies: {
    type: Boolean,
    default: true
  },
  maxTileCacheSize: {
    type: Number,
    default: null
  },
  localIdeographFontFamily: {
    type: String,
    default: "sans-serif"
  },
  transformRequest: {
    type: Function,
    default: null
  },
  collectResourceTiming: {
    type: Boolean,
    default: false
  },
  fadeDuration: {
    type: Number,
    default: 300
  },
  crossSourceCollisions: {
    type: Boolean,
    default: true
  },
  cooperativeGestures: {
    type: Boolean
  },
  language: {
    type: [String, Array],
    default: null
  },
  locale: {
    type: Object,
    default: null
  },
  localFontFamily: {
    type: [Boolean, String],
    default: false
  },
  minTileCacheSize: {
    type: Number,
    default: null
  },
  optimizeForTerrain: {
    type: Boolean,
    default: true
  },
  performanceMetricsCollection: {
    type: Boolean,
    default: true
  },
  projection: {
    type: [String, Object],
    default: "mercator"
  },
  testMode: {
    type: Boolean,
    default: false
  },
  touchPitch: {
    type: [Boolean, Object],
    default: true
  },
  useWebGL2: {
    type: Boolean,
    default: false
  },
  worldview: {
    type: String,
    default: null
  }
};
const events$3 = [
  "boxzoomcancel",
  "boxzoomend",
  "boxzoomstart",
  "click",
  "contextmenu",
  "data",
  "dataloading",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "error",
  "idle",
  "load",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "move",
  "moveend",
  "movestart",
  "pitch",
  "pitchend",
  "pitchstart",
  "remove",
  "render",
  "resize",
  "rotate",
  "rotateend",
  "rotatestart",
  "sourcedata",
  "sourcedataloading",
  "styledata",
  "styledataloading",
  "styleimagemissing",
  "touchcancel",
  "touchend",
  "touchmove",
  "touchstart",
  "webglcontextlost",
  "webglcontextrestored",
  "wheel",
  "zoom",
  "zoomend",
  "zoomstart"
];
const __default__ = {
  inheritAttrs: false
};
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  ...__default__,
  __name: "MapboxMap",
  props: propsConfig$6,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const map = shallowRef(null);
    provide("mapbox-map", map);
    const root = ref();
    const isLoaded = ref(false);
    const options = computed(() => {
      const { accessToken, mapStyle: style, ...options2 } = props;
      if (!options2.container && root.value) {
        options2.container = root.value;
      }
      return { style, ...options2 };
    });
    useEventsBinding(emit, map, events$3);
    usePropsBinding(props, map, propsConfig$6);
    onMounted(() => {
      mapboxgl.accessToken = props.accessToken;
      map.value = new mapboxgl.Map(options.value);
      map.value.on("load", () => {
        isLoaded.value = true;
      });
      emit("mb-created", map.value);
      const resizeObserver = new ResizeObserver(() => {
        map.value.resize();
      });
      resizeObserver.observe(options.value.container);
      onUnmounted(() => {
        resizeObserver.disconnect();
        map.value.remove();
      });
    });
    __expose({ map });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("div", mergeProps({
          ref_key: "root",
          ref: root
        }, _ctx.$attrs), null, 16),
        isLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
          renderSlot(_ctx.$slots, "default")
        ])) : (openBlock(), createElementBlock("div", _hoisted_2, [
          renderSlot(_ctx.$slots, "loader")
        ]))
      ], 64);
    };
  }
});
function debounce(fn, delay = 300) {
  let timeout;
  return function debounced(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn(...args);
    }, delay);
  };
}
const _hoisted_1$2 = { class: "scroller__content" };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "VueScroller",
  emits: ["scroll-top", "scroll-bottom"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const scroller = ref();
    const scrollTop = ref(0);
    const scrollMax = ref(Number.POSITIVE_INFINITY);
    function setVars() {
      if (!unref(scroller)) {
        return;
      }
      const unrefScroller = unref(scroller);
      scrollTop.value = unrefScroller.scrollTop;
      scrollMax.value = unrefScroller.scrollHeight - unrefScroller.clientHeight;
      if (scrollTop.value === 0) {
        emit("scroll-top");
      }
      if (scrollTop.value === scrollMax.value) {
        emit("scroll-bottom");
      }
    }
    const debouncedSetVars = debounce(setVars);
    onUpdated(() => {
      setVars();
    });
    onMounted(async () => {
      unref(scroller).addEventListener("scroll", setVars, { passive: true });
      window.addEventListener("resized", debouncedSetVars);
      await nextTick();
      setVars();
    });
    onBeforeUnmount(() => {
      unref(scroller).removeEventListener("scroll", setVars);
      window.removeEventListener("resized", debouncedSetVars);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["scroller", {
          "scroller--is-top": scrollTop.value === 0,
          "scroller--is-bottom": scrollTop.value === scrollMax.value,
          "scroller--has-no-scroll": scrollTop.value === 0 && scrollMax.value === 0
        }])
      }, [
        createElementVNode("div", {
          ref_key: "scroller",
          ref: scroller,
          class: "scroller__inner"
        }, [
          createElementVNode("div", _hoisted_1$2, [
            renderSlot(_ctx.$slots, "default")
          ])
        ], 512)
      ], 2);
    };
  }
});
const _hoisted_1$1 = ["onClick"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "StoreLocator",
  props: {
    /**
     * A list of items to display.
     * The only required properties are `lat` and `lng` and `id`.
     * @type {Array<{ lat: number, lng: number, id: string } & Record<string, unknown>>}
     */
    items: {
      type: Array,
      required: true
    },
    /**
     * The zoom level to use when zooming in on an item.
     * @type {number}
     */
    itemZoomLevel: {
      type: Number,
      default: 14
    },
    /**
     * A Mapbox access token.
     * @type {object}
     */
    accessToken: {
      type: String,
      default: "no-token"
    },
    /**
     * Props for the MapboxMap component.
     * @see  https://vue-mapbox-gl.meta.fr/components/MapboxMap.html#props
     * @type {object}
     */
    mapboxMap: {
      type: Object,
      default: () => ({})
    },
    /**
     * Props fof the MapboxCluster component.
     * @see  https://vue-mapbox-gl.meta.fr/components/MapboxCluster.html#props
     * @type {object}
     */
    mapboxCluster: {
      type: Object,
      default: () => ({})
    },
    /**
     * Props for the MapboxGeocoder component.
     * @see  https://vue-mapbox-gl.meta.fr/components/MapboxGeocoder.html#props
     * @type {object}
     */
    mapboxGeocoder: {
      type: Object,
      default: () => ({})
    },
    /**
     * Configuration for each transition component.
     * @type {object}
     */
    transitions: {
      type: Object,
      default: () => ({
        loader: {
          map: {},
          search: {},
          list: {},
          default: {}
        },
        panel: {}
      })
    },
    /**
     * Define custom classes for each element of the component.
     * @type {object}
     */
    classes: {
      type: Object,
      default: () => {
        const root = "store-locator";
        const bem = (name, modifier = "") => `${root}__${name}${modifier ? `--${modifier}` : ""}`;
        return {
          root,
          region: {
            map: [bem("region"), bem("region", "map")],
            search: [bem("region"), bem("region", "search")],
            list: [bem("region"), bem("region", "list")],
            panel: [bem("region"), bem("region", "panel")]
          },
          map: bem("map"),
          search: bem("search"),
          list: bem("list"),
          listItem: bem("list-item"),
          panel: bem("panel")
        };
      }
    },
    /**
     * Filter items callback function
     * @type {Function}
     */
    filterItemsCallback: {
      type: [Function, Boolean],
      default: false
    },
    /**
     * Disable the zoom when clicking on a Feature.
     */
    disableFeatureClickZoom: Boolean
  },
  emits: [
    "geocoder-created",
    "map-created",
    "map-load",
    "select-item",
    "cluster-feature-click",
    "select-item",
    "cluster-feature-mouseenter",
    "cluster-feature-mouseleave",
    "cluster-cluster-click"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const map = ref();
    const isLoading = ref(true);
    const mapIsMoving = ref(false);
    const selectedItem = ref(null);
    const filteredItems = ref(
      props.items.map((item) => item)
    );
    const listIsLoading = ref(false);
    function itemToGeoJsonFeature({ lat, lng, ...properties }) {
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [lng, lat]
        },
        properties
      };
    }
    const geoJson = computed(() => ({
      type: "FeatureCollection",
      features: props.items.map(itemToGeoJsonFeature)
    }));
    const filteredGeoJson = computed(() => ({
      type: "FeatureCollection",
      features: unref(filteredItems).map(itemToGeoJsonFeature)
    }));
    async function filterFeaturesInView() {
      listIsLoading.value = true;
      const mapBounds = unref(map).getBounds();
      const center = unref(map).getCenter();
      filteredItems.value = props.items.filter(({ lng, lat }) => mapBounds.contains([lng, lat])).sort((a, b) => {
        const distanceFromA = center.distanceTo(a);
        const distanceFromB = center.distanceTo(b);
        if (distanceFromA < distanceFromB) {
          return -1;
        }
        if (distanceFromA > distanceFromB) {
          return 1;
        }
        return 0;
      });
      if (props.filterItemsCallback && typeof props.filterItemsCallback === "function") {
        filteredItems.value = await props.filterItemsCallback(filteredItems.value, map.value);
      }
      await nextTick();
      listIsLoading.value = false;
    }
    function onGeocoderResult({ result }) {
      if (result.bbox) {
        unref(map).fitBounds(result.bbox);
      } else if (result.center) {
        unref(map).flyTo({ center: result.center });
      }
    }
    function onGeocoderCreated(geocoder) {
      emit("geocoder-created", geocoder);
    }
    async function onMapCreated(instance) {
      map.value = instance;
      emit("map-created", instance);
      await nextTick();
      filterFeaturesInView();
    }
    async function onMapLoad() {
      await nextTick();
      isLoading.value = false;
      emit("map-load", map);
    }
    async function onMapMovestart() {
      mapIsMoving.value = true;
      await nextTick();
      listIsLoading.value = true;
    }
    function onMapMoveend() {
      mapIsMoving.value = false;
      filterFeaturesInView();
    }
    function onListItemClick(item) {
      selectedItem.value = item;
      emit("select-item", item);
      const { lat, lng } = unref(map).getCenter();
      if (Math.abs(lng - item.lng) > 1e-4 && Math.abs(lat - item.lat) > 1e-4) {
        unref(map).flyTo({ center: [item.lng, item.lat], zoom: props.itemZoomLevel });
      }
    }
    function onClusterFeatureClick(feature, event) {
      const item = props.items.find(({ id }) => id === feature.properties.id);
      emit("cluster-feature-click", feature, event);
      if (item) {
        emit("select-item", item);
        selectedItem.value = item;
        if (props.disableFeatureClickZoom) {
          return;
        }
        unref(map).flyTo({ center: feature.geometry.coordinates, zoom: props.itemZoomLevel });
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(__props.classes.root || {})
      }, [
        createElementVNode("div", {
          class: normalizeClass((__props.classes.region || {}).map || {})
        }, [
          isLoading.value ? (openBlock(), createBlock(Transition, normalizeProps(mergeProps({ key: 0 }, (__props.transitions.loader || {}).map || {})), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "map-loader", {}, () => [
                createVNode(Transition, normalizeProps(guardReactiveProps((__props.transitions.loader || {}).default || {})), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "loader", {}, () => [
                      _cache[3] || (_cache[3] = createTextVNode("Loading..."))
                    ])
                  ]),
                  _: 3
                }, 16)
              ])
            ]),
            _: 3
          }, 16)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "before-map"),
          createVNode(_sfc_main$9, mergeProps({
            class: __props.classes.map || {}
          }, { ...__props.mapboxMap, accessToken: __props.accessToken }, {
            onMbCreated: onMapCreated,
            onMbMovestart: onMapMovestart,
            onMbMoveend: onMapMoveend,
            onMbLoad: onMapLoad
          }), {
            default: withCtx(() => [
              createVNode(_sfc_main$b, mergeProps({ ...__props.mapboxCluster, data: filteredGeoJson.value }, {
                onMbFeatureClick: onClusterFeatureClick,
                onMbFeatureMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.$emit("cluster-feature-mouseenter", ...args)),
                onMbFeatureMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.$emit("cluster-feature-mouseleave", ...args)),
                onMbClusterClick: _cache[2] || (_cache[2] = (...args) => _ctx.$emit("cluster-cluster-click", ...args))
              }), null, 16),
              renderSlot(_ctx.$slots, "map", {
                map: map.value,
                geojson: geoJson.value,
                filteredGeojson: filteredGeoJson.value,
                items: __props.items,
                filteredItems: filteredItems.value,
                selectedItem: selectedItem.value
              })
            ]),
            _: 3
          }, 16, ["class"]),
          renderSlot(_ctx.$slots, "after-map")
        ], 2),
        createElementVNode("div", {
          class: normalizeClass((__props.classes.region || {}).search || {})
        }, [
          isLoading.value ? (openBlock(), createBlock(Transition, normalizeProps(mergeProps({ key: 0 }, (__props.transitions.loader || {}).search || {})), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "search-loader", {}, () => [
                createVNode(Transition, normalizeProps(guardReactiveProps((__props.transitions.loader || {}).default || {})), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "loader", {}, () => [
                      _cache[4] || (_cache[4] = createTextVNode("Loading..."))
                    ])
                  ]),
                  _: 3
                }, 16)
              ])
            ]),
            _: 3
          }, 16)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "before-search", {
            items: __props.items,
            filteredItems: filteredItems.value,
            selectedItem: selectedItem.value
          }),
          createVNode(_sfc_main$a, mergeProps({
            class: __props.classes.search || {}
          }, { ...__props.mapboxGeocoder, accessToken: __props.accessToken }, {
            onMbResult: onGeocoderResult,
            onMbCreated: onGeocoderCreated
          }), null, 16, ["class"]),
          renderSlot(_ctx.$slots, "after-search", {
            items: __props.items,
            filteredItems: filteredItems.value,
            selectedItem: selectedItem.value
          })
        ], 2),
        createElementVNode("div", {
          class: normalizeClass((__props.classes.region || {}).list || {})
        }, [
          isLoading.value || listIsLoading.value ? (openBlock(), createBlock(Transition, normalizeProps(mergeProps({ key: 0 }, (__props.transitions.loader || {}).list || {})), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "list-loader", {}, () => [
                createVNode(Transition, normalizeProps(guardReactiveProps((__props.transitions.loader || {}).default || {})), {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "loader", {}, () => [
                      _cache[5] || (_cache[5] = createTextVNode("Loading..."))
                    ])
                  ]),
                  _: 3
                }, 16)
              ])
            ]),
            _: 3
          }, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            renderSlot(_ctx.$slots, "before-list", {
              items: __props.items,
              filteredItems: filteredItems.value,
              selectedItem: selectedItem.value
            }, () => [
              createElementVNode("p", null, "Result(s): " + toDisplayString(filteredItems.value.length.toFixed(0)), 1)
            ]),
            filteredItems.value.length > 0 ? (openBlock(), createBlock(_sfc_main$8, { key: 0 }, {
              default: withCtx(() => [
                createElementVNode("ul", {
                  class: normalizeClass(__props.classes.list || {})
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(filteredItems.value, (item, index2) => {
                    return openBlock(), createElementBlock("li", {
                      key: item.id,
                      class: normalizeClass(__props.classes.listItem || {}),
                      onClick: ($event) => onListItemClick(item)
                    }, [
                      renderSlot(_ctx.$slots, "list-item", {
                        item,
                        index: index2,
                        selectedItem: selectedItem.value
                      }, () => [
                        createTextVNode(" Lat: " + toDisplayString(item.lat) + " ", 1),
                        _cache[6] || (_cache[6] = createElementVNode("br", null, null, -1)),
                        createTextVNode(" Lng: " + toDisplayString(item.lng), 1)
                      ])
                    ], 10, _hoisted_1$1);
                  }), 128))
                ], 2)
              ]),
              _: 3
            })) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "after-list", {
              items: __props.items,
              filteredItems: filteredItems.value,
              selectedItem: selectedItem.value,
              filterFeaturesInView
            })
          ], 64))
        ], 2),
        createElementVNode("div", {
          class: normalizeClass((__props.classes.region || {}).panel || {})
        }, [
          createVNode(Transition, normalizeProps(guardReactiveProps(__props.transitions.panel || {})), {
            default: withCtx(() => [
              selectedItem.value ? (openBlock(), createElementBlock("div", {
                key: selectedItem.value.id,
                class: normalizeClass(__props.classes.panel || {})
              }, [
                renderSlot(_ctx.$slots, "panel", {
                  item: selectedItem.value,
                  close: () => selectedItem.value = null
                }, () => [
                  createElementVNode("div", null, toDisplayString(selectedItem.value), 1)
                ])
              ], 2)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 16)
        ], 2)
      ], 2);
    };
  }
});
if (!mapboxgl) {
  throw new Error("mapboxgl is not installed.");
}
const { GeolocateControl } = mapboxgl;
const propsConfig$5 = {
  positionOptions: {
    type: Object,
    default: () => ({ enableHighAccuracy: false, timeout: 6e3 })
  },
  fitBoundsOptions: {
    type: Object,
    default: () => ({ maxZoom: 15 })
  },
  trackUserLocation: {
    type: Boolean,
    default: false
  },
  showAccuracyCircle: {
    type: Boolean,
    default: true
  },
  showUserHeading: {
    type: Boolean,
    default: true
  },
  showUserLocation: {
    type: Boolean,
    default: true
  },
  position: {
    type: String,
    default: "top-right",
    bind: false
  }
};
const events$2 = [
  "trackuserlocationend",
  "error",
  "geolocate",
  "outofmaxbounds",
  "trackuserlocationstart"
];
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "MapboxGeolocateControl",
  props: propsConfig$5,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { control } = useControl(GeolocateControl, { propsConfig: propsConfig$5, events: events$2, props, emit });
    __expose({ control });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});
const _hoisted_1 = ["id"];
const propsConfig$4 = {
  /**
   * The ID of the image
   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addimage
   * @type {string}
   */
  id: {
    type: String,
    required: true
  },
  /**
   * The image as String, an HTMLImageElement, ImageData, or object with
   * width, height, and data properties with the same format as ImageData.
   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addimage
   * @type {string | HTMLImageElement | ImageData | object}
   */
  src: {
    type: [
      String,
      typeof HTMLImageElement !== "undefined" && HTMLImageElement,
      typeof ImageData !== "undefined" && ImageData,
      Object
    ],
    required: true
  },
  /**
   * The options object for the image to add
   * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addimage
   * @type {object}
   */
  options: {
    type: Object,
    default: () => ({ pixelRatio: 1, sdf: false })
  }
};
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "MapboxImage",
  props: propsConfig$4,
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const { map } = useMap();
    const isReady = ref(false);
    async function loadImage(src) {
      return new Promise((resolve, reject) => {
        unref(map).loadImage(src, (err, data) => {
          if (err) {
            return reject(err);
          }
          return resolve(data);
        });
      });
    }
    watch(
      () => props.src,
      async (newValue) => {
        const image = typeof newValue !== "string" ? newValue : await loadImage(newValue);
        unref(map).updateImage(props.id, image);
      },
      { deep: true }
    );
    onMounted(async () => {
      const { id, src, options } = props;
      const image = typeof src !== "string" ? src : await loadImage(src);
      unref(map).addImage(id, image, options);
      emit("mb-add", { id, image, options });
      isReady.value = true;
    });
    onUnmounted(() => {
      if (unref(map) && unref(map).hasImage(props.id)) {
        unref(map).removeImage(props.id);
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", { id: _ctx.id }, [
        isReady.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
      ], 8, _hoisted_1);
    };
  }
});
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "MapboxImages",
  props: {
    /**
     * A list of sources to add to the map
     * @see  https://docs.mapbox.com/mapbox-gl-js/api/#map#addimage
     * @see  ./MapboxImage.vue
     * @type {object}
     */
    sources: {
      type: Array,
      required: true
    }
  },
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const isReady = ref(false);
    const addedImages = /* @__PURE__ */ new Map();
    function addHandler(image, index2) {
      if (!addedImages.has(image.id)) {
        addedImages.set(image.id, image);
        emit("mb-add", image, index2, props.sources.length);
      }
      if (addedImages.size === props.sources.length) {
        isReady.value = true;
        emit("mb-ready", addedImages.values());
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.sources, (source, index2) => {
          return openBlock(), createBlock(_sfc_main$5, mergeProps({
            key: `mapbox-images-${source.id}`,
            ref_for: true
          }, source, {
            onMbAdd: ($event) => addHandler($event, index2 + 1)
          }), null, 16, ["onMbAdd"]);
        }), 128)),
        isReady.value ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
      ]);
    };
  }
});
const { Popup, Point: Point$1, LngLat } = mapboxgl;
const propsConfig$3 = {
  lngLat: {
    type: [LngLat, Array, Object],
    required: true
  },
  closeButton: {
    type: Boolean,
    default: true
  },
  closeOnClick: {
    type: Boolean,
    default: true
  },
  closeOnMove: {
    type: Boolean,
    default: false
  },
  anchor: {
    type: String,
    default: null
  },
  offset: {
    type: [Number, Point$1, Array, Object],
    default: 0
  },
  className: {
    type: String,
    default: null
  },
  maxWidth: {
    type: String,
    default: "240px"
  },
  /**
   * Do not render the popup on the map.
   * @type {object}
   */
  renderless: {
    type: Boolean,
    default: false,
    bind: false
  }
};
const events$1 = ["open", "close"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "MapboxPopup",
  props: propsConfig$3,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const popup = shallowRef();
    const root = ref();
    const options = computed(() => {
      const { lngLat, ...options2 } = props;
      return options2;
    });
    usePropsBinding(props, popup, propsConfig$3);
    useEventsBinding(emit, popup, events$1);
    onMounted(() => {
      const { map } = useMap();
      popup.value = new Popup(options.value).setLngLat(props.lngLat).setDOMContent(root.value);
      if (!props.renderless) {
        popup.value.addTo(map.value);
      }
      emit("mb-open", popup.value);
    });
    onUnmounted(() => {
      if (popup.value) {
        popup.value.remove();
      }
    });
    __expose({ popup });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "root",
        ref: root
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 512);
    };
  }
});
const { Marker, Point } = mapboxgl;
const propsConfig$2 = {
  lngLat: {
    type: Array,
    required: true
  },
  popup: {
    type: [Object, Boolean],
    default: false,
    bind: false
  },
  element: {
    type: typeof HTMLElement !== "undefined" ? HTMLElement : Object,
    default: null
  },
  offset: {
    type: [Point, Array],
    default: null
  },
  anchor: {
    type: String,
    default: "center"
  },
  color: {
    type: String,
    default: null
  },
  scale: {
    type: Number,
    default: 1
  },
  draggable: {
    type: Boolean,
    default: false
  },
  rotation: {
    type: Number,
    default: 0
  },
  pitchAlignment: {
    type: String,
    default: "auto"
  },
  rotationAlignment: {
    type: String,
    default: "auto"
  },
  /**
   * Do not render the popup on the map.
   * @type {object}
   */
  renderless: {
    type: Boolean,
    default: false,
    bind: false
  }
};
const events = ["dragstart", "drag", "dragend"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "MapboxMarker",
  props: propsConfig$2,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const slots = useSlots();
    const marker = shallowRef();
    const contentRef = ref();
    const popupRef = ref();
    const hasPopup = computed(() => typeof slots.popup !== "undefined");
    const popupInstance = computed(() => hasPopup.value ? popupRef.value.popup : null);
    const popupOptions = computed(
      () => ({
        lngLat: props.lngLat,
        ...props.popup ? props.popup : {},
        renderless: true
      })
    );
    const options = computed(() => {
      const { lngLat, popup, ...options2 } = props;
      if (slots.default) {
        options2.element = contentRef.value;
      }
      return options2;
    });
    usePropsBinding(props, marker, propsConfig$2);
    useEventsBinding(emit, marker, events);
    onMounted(() => {
      const { map } = useMap();
      marker.value = new Marker(options.value).setLngLat(props.lngLat);
      if (!props.renderless) {
        marker.value.addTo(map.value);
      }
      if (hasPopup.value) {
        marker.value.setPopup(popupInstance.value);
      }
    });
    onUnmounted(() => {
      if (marker.value) {
        marker.value.remove();
      }
    });
    __expose({ marker, popup: popupInstance });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("div", {
          ref_key: "contentRef",
          ref: contentRef
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 512),
        hasPopup.value ? (openBlock(), createBlock(_sfc_main$3, mergeProps({
          key: 0,
          ref_key: "popupRef",
          ref: popupRef
        }, popupOptions.value), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "popup")
          ]),
          _: 3
        }, 16)) : createCommentVNode("", true)
      ]);
    };
  }
});
const propsConfig$1 = {
  showCompass: {
    type: Boolean,
    default: true
  },
  showZoom: {
    type: Boolean,
    default: true
  },
  visualizePitch: {
    type: Boolean,
    default: false
  },
  position: {
    type: String,
    default: "top-right",
    bind: false
  }
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "MapboxNavigationControl",
  props: propsConfig$1,
  setup(__props, { expose: __expose }) {
    const { NavigationControl } = mapboxgl;
    const props = __props;
    const { control } = useControl(NavigationControl, { props, propsConfig: propsConfig$1 });
    __expose({ control });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div");
    };
  }
});
if (!mapboxgl) {
  throw new Error("mapboxgl is not installed.");
}
const propsConfig = {
  // eslint-disable-next-line vue/require-default-prop
  container: typeof HTMLElement !== "undefined" ? HTMLElement : Object,
  position: {
    type: String,
    default: "top-right"
  }
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "MapboxFullscreenControl",
  props: propsConfig,
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { control } = useControl(mapboxgl.FullscreenControl, {
      propsConfig,
      props
    });
    __expose({ control });
    return () => {
    };
  }
});
export {
  _sfc_main$b as MapboxCluster,
  _sfc_main as MapboxFullscreenControl,
  _sfc_main$a as MapboxGeocoder,
  _sfc_main$6 as MapboxGeolocateControl,
  _sfc_main$5 as MapboxImage,
  _sfc_main$4 as MapboxImages,
  _sfc_main$d as MapboxLayer,
  _sfc_main$9 as MapboxMap,
  _sfc_main$2 as MapboxMarker,
  _sfc_main$1 as MapboxNavigationControl,
  _sfc_main$3 as MapboxPopup,
  _sfc_main$c as MapboxSource,
  _sfc_main$7 as StoreLocator,
  _sfc_main$8 as VueScroller,
  useControl,
  useEventsBinding,
  useMap,
  usePropsBinding
};
//# sourceMappingURL=index.js.map
